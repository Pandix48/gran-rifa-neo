<script>
  // ====== Básicos ======
  const qs = (s, r=document) => r.querySelector(s);
  const statusEl    = qs('#status');
  const boardEl     = qs('#board');
  const winnersBody = qs('#winnersBody');
  const emptyMsg    = qs('#emptyMsg');
  const urlp        = new URLSearchParams(location.search);
  const room        = (urlp.get('room') || 'demo').trim();
  const isAdmin     = urlp.get('admin') === '1';
  if (isAdmin) qs('#controls').style.display = 'block';

  // ====== Voz ======
  const voiceSelect = qs('#voiceSelect');
  const volRange    = qs('#volRange');
  const rateRange   = qs('#rateRange');
  const speak = (text) => {
    if (!('speechSynthesis' in window)) return;
    const u = new SpeechSynthesisUtterance(text);
    u.volume = parseFloat(volRange?.value ?? '1');
    u.rate   = parseFloat(rateRange?.value ?? '1');
    const id = voiceSelect?.value;
    const voices = speechSynthesis.getVoices();
    const v = voices.find(v => v.voiceURI === id || v.name === id);
    if (v) u.voice = v;
    speechSynthesis.speak(u);
  };
  function populateVoices() {
    if (!('speechSynthesis' in window) || !voiceSelect) return;
    const voices = speechSynthesis.getVoices();
    voiceSelect.innerHTML = '';
    voices.forEach(v => {
      const opt = document.createElement('option');
      opt.value = v.voiceURI || v.name;
      opt.textContent = `${v.name} (${v.lang})`;
      voiceSelect.appendChild(opt);
    });
  }
  if ('speechSynthesis' in window) {
    speechSynthesis.onvoiceschanged = populateVoices;
    populateVoices();
    qs('#btnTestVoice')?.addEventListener('click', () => speak('Esta es una prueba de voz.'));
  }

  // ====== Dibujo del tablero ======
  function shapeSVG(type) {
    if (type === 'circle')  return `<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/></svg>`;
    if (type === 'diamond') return `<svg viewBox="0 0 24 24"><path d="M12 2 L22 12 L12 22 L2 12 Z"/></svg>`;
    return `<svg viewBox="0 0 24 24"><path d="M12 2l2.95 6.31 6.92.56-5.26 4.48 1.64 6.74L12 16.9 5.75 20.1l1.64-6.74L2.13 8.87l6.92-.56L12 2z"/></svg>`;
  }
  const gridCols = n => Math.ceil(Math.sqrt(n));

  // ====== Estado de UI para evitar “parpadeos” mientras editas ======
  let isEditing = false;      // true mientras hay un nombre en modo edición
  let editingIndex = null;    // índice de la celda que estás editando (o null)
  let lastState = null;       // última foto del estado dibujado
  let lastWinnersCount = 0;   // para anunciar solo ganadores nuevos

  // ====== Auto-Next (Start) ======
  let autoNextTimer = null;
  let autoNextEvery = null;  // ms actual programado

  function clearAutoNext(){
    if (autoNextTimer) {
      clearInterval(autoNextTimer);
      autoNextTimer = null;
      autoNextEvery = null;
    }
  }

  async function ensureAutoNext(state){
    if (!isAdmin) { clearAutoNext(); return; } // solo el admin dispara el auto-next
    const ms = Math.max(1000, state?.intervalMs || 5000);

    if (!state?.running) { clearAutoNext(); return; }

    // si cambia el intervalo, reinicio
    if (autoNextEvery !== ms) {
      clearAutoNext();
      autoNextEvery = ms;
      autoNextTimer = setInterval(async () => {
        try {
          await call('next');
          // no forzamos render inmediato; poll cada 1s lo traerá
        } catch (e) { /* ignore */ }
      }, ms);
    }
  }

  function render(state) {
    if (!state) {
      statusEl.textContent = 'Esperando estado…';
      boardEl.innerHTML = '';
      winnersBody.innerHTML = '';
      emptyMsg.style.display = 'block';
      return;
    }

    // Programa/ajusta el auto-next en base al estado
    ensureAutoNext(state);

    const marcadas = (state.filledCounts || []).filter(c => c >= (state.numShapes||1)).length;
    const shapeTxt = (state.shapeType || state.shape || 'star');
    statusEl.textContent =
      `Estado: forma=${shapeTxt} | celdas=${state.numCells} | formas/celda=${state.numShapes} | marcadas=${marcadas} | corriendo=${!!state.running}`;

    // Si estás editando un nombre, NO redibujamos el tablero para no “sacarte” el foco
    // (aún así actualizamos zona de ganadores y status arriba)
    if (isEditing) {
      // solo repintamos ganadores si cambian
      paintWinners(state);
      lastState = state;
      return;
    }

    // Tablero
    const n    = state.numCells || 20;
    const cols = gridCols(n);
    boardEl.style.gridTemplateColumns = `repeat(${cols}, minmax(120px, 1fr))`;
    boardEl.innerHTML = '';

    for (let i = 0; i < n; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';

      const name = (state.names && state.names[i]) ? state.names[i] : `#${i+1}`;
      const h4 = document.createElement('h4');
      h4.textContent = name;

      // Editar nombre inline (solo admin)
      if (isAdmin) {
        h4.title = 'Haz clic para editar. Enter o salir para guardar';
        h4.style.cursor = 'text';
        h4.addEventListener('click', () => {
          // Marca edición y deja de redibujar hasta que guardemos
          isEditing = true;
          editingIndex = i;
          h4.setAttribute('contenteditable', 'true');
          h4.focus();
          document.execCommand('selectAll', false, null);
        });
        const commit = async () => {
          if (!isEditing || editingIndex !== i) return;
          h4.removeAttribute('contenteditable');
          const newName = h4.textContent.trim() || `#${i+1}`;
          // Guardamos solo si cambió
          if (state.names[i] !== newName) {
            state.names[i] = newName;
            try { await call('setNames', { names: state.names }); } catch {}
          }
          isEditing = false;
          editingIndex = null;
          // tras guardar, el poll normal redibujará
        };
        h4.addEventListener('blur', commit);
        h4.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') { e.preventDefault(); h4.blur(); }
        });
      }

      cell.appendChild(h4);

      const shapesWrap = document.createElement('div');
      shapesWrap.className = 'shapes';
      const totalShapes = state.numShapes || 2;
      const filled = (state.filledCounts && state.filledCounts[i]) || 0;
      const type = (state.shapeType || state.shape || 'star');
      for (let j = 0; j < totalShapes; j++) {
        const d = document.createElement('div');
        d.className = `shape ${type} ${j < filled ? 'filled' : ''}`;
        d.innerHTML = shapeSVG(type);
        shapesWrap.appendChild(d);
      }
      cell.appendChild(shapesWrap);
      boardEl.appendChild(cell);
    }

    paintWinners(state);
    lastState = state;

    // Si es admin, refrescamos lista de premios en el gestor
    if (isAdmin) drawPrizes(state.prizes || []);
  }

  function paintWinners(state){
    const winners = state.winners || [];
    winnersBody.innerHTML = '';
    emptyMsg.style.display = winners.length ? 'none' : 'block';

    winners.forEach((w, idx) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${idx+1}</td><td>${(w.name || ('#'+(w.number||'-')))} — ${w.prize||'Premio'}</td>`;
      winnersBody.appendChild(tr);
    });

    // Anuncio por voz solo cuando hay uno nuevo y SOLO en admin
    if (isAdmin && winners.length > lastWinnersCount) {
      const nw = winners[winners.length - 1];
      const num = nw?.number ?? '?';
      const prize = nw?.prize ?? 'premio';
      speak(`Número ${num}, felicidades, ganaste ${prize}.`);
    }
    lastWinnersCount = winners.length;
  }

  // ====== Llamadas backend ======
  async function call(action, payload={}) {
    const res = await fetch('/.netlify/functions/state', {
      method: 'POST',
      headers: { 'content-type':'application/json' },
      body: JSON.stringify({ room, action, ...payload })
    });
    const data = await res.json().catch(()=>({}));
    if (!data.ok) throw new Error(data.error||'Error');
    return data.state;
  }
  async function fetchState() {
    const url = new URL('/.netlify/functions/state', location.origin);
    url.searchParams.set('room', room);
    const res = await fetch(url.toString());
    const data = await res.json().catch(()=>({}));
    if (data && data.ok) return data.state || null;
    return null;
  }

  // ====== Poll ======
  async function poll() {
    try {
      const s = await fetchState();
      // Si estás editando un nombre, no redibuja el tablero
      render(s);
    } catch {}
  }
  poll();
  setInterval(poll, 1000);

  // ====== Eventos admin ======
  if (isAdmin) {
    qs('#btnGenerate').onclick = async () => {
      clearAutoNext();
      const n = parseInt(qs('#numCells').value||'20',10);
      const k = parseInt(qs('#numShapes').value||'2',10);
      const shape = qs('#shapeType').value||'star';
      const intervalMs = Math.max(1000, parseInt((qs('#intervalSec').value||'5'),10)*1000);
      await call('generate', { n, k, shape, intervalMs }); poll();
    };
    qs('#btnReset').onclick = async () => { clearAutoNext(); await call('reset'); poll(); };
    qs('#btnStart').onclick = async () => { await call('start'); poll(); };
    qs('#btnStop').onclick  = async () => { clearAutoNext(); await call('stop');  poll(); };
    qs('#btnNext').onclick  = async () => { await call('next');  poll(); };

    // Nombres masivos
    qs('#btnSaveNames').onclick = async () => {
      const raw = (qs('#namesText').value || '').trim();
      const names = raw.split('\n').map(s => s.trim()).filter(Boolean);
      await call('setNames', { names }); poll();
    };
  }

  // ====== Gestor de premios ======
  const prizesList  = qs('#prizesList');
  const newPrizeTxt = qs('#newPrizeText');
  function drawPrizes(prizes) {
    if (!prizesList) return;
    prizesList.innerHTML = '';
    prizes.forEach((p, idx) => {
      const row = document.createElement('div');
      row.className = 'prize-row';
      const inp = document.createElement('input');
      inp.type = 'text'; inp.value = p;
      const del = document.createElement('button');
      del.textContent = 'Eliminar'; del.className = 'bad';
      row.appendChild(inp); row.appendChild(del);
      prizesList.appendChild(row);

      inp.addEventListener('change', () => {
        // Solo cambia en UI; al pulsar "Guardar lista" se envía todo
      });
      del.addEventListener('click', async () => {
        await call('removePrize', { index: idx });
        poll();
      });
    });
  }
  qs('#btnAddPrize')?.addEventListener('click', async () => {
    const name = (newPrizeTxt.value || '').trim();
    if (!name) return;
    await call('addPrize', { prize: name });
    newPrizeTxt.value = '';
    poll();
  });
  qs('#btnSavePrizes')?.addEventListener('click', async () => {
    const rows = prizesList.querySelectorAll('input[type="text"]');
    const prizes = Array.from(rows).map(i => i.value.trim()).filter(Boolean);
    await call('setPrizes', { prizes });
    poll();
  });
</script>



