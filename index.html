<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gran Rifa — Netlify</title>
<style>
  :root{
    --bg:#f6f7fb;
    --panel:#fff;
    --ink:#111827;
    --muted:#6b7280;
    --accent:#2563eb;
    --good:#16a34a;
    --bad:#dc2626;
    --border:#e5e7eb;
    --star:#fbbf24;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,Apple Color Emoji,Segoe UI Emoji;
    color:var(--ink);
    background:var(--bg);
  }
  header{
    padding:12px 16px;
    border-bottom:1px solid var(--border);
    background:#fff;
    position:sticky; top:0; z-index:5;
  }
  .wrap{max-width:1200px;margin:16px auto;padding:0 16px}
  h1{font-size:16px;margin:0}
  #status{color:var(--muted); font-size:13px}

  /* Paneles */
  .panel{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:10px;
    padding:16px;
    margin-bottom:16px;
  }
  .panel h2{
    margin:0 0 8px 0; font-size:18px;
  }
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .row > *{margin:4px 0}
  label{font-size:12px;color:var(--muted)}
  input, select, textarea, button{
    font:inherit; padding:8px 10px; border:1px solid var(--border); border-radius:8px; background:#fff;
  }
  input[type="number"]{width:90px}
  textarea{width:100%; min-height:120px; resize:vertical}
  button{cursor:pointer}
  .primary{background:var(--accent); color:#fff; border-color:transparent}
  .good{background:var(--good); color:#fff; border-color:transparent}
  .bad{background:var(--bad); color:#fff; border-color:transparent}

  /* tablero */
  #board{
    display:grid; gap:10px;
    grid-template-columns: repeat(5, minmax(120px,1fr));
  }
  .cell{
    background:#fff;border:1px solid var(--border);border-radius:10px;padding:10px;
  }
  .cell h4{
    margin:0 0 6px 0; font-size:13px; color:var(--muted);
    overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
  }
  .shapes{display:flex; gap:6px; flex-wrap:wrap}
  .shape svg{width:18px;height:18px; fill:#e5e7eb}
  .shape.filled svg{fill:var(--star)}

  /* tabla ganadores */
  table{width:100%;border-collapse:collapse}
  td, th{padding:8px;border-top:1px solid var(--border); font-size:14px}
  th{text-align:left;color:var(--muted)}
  .muted{color:var(--muted);font-size:13px}
  .prize-row{display:flex; gap:8px; align-items:center; margin-bottom:8px}
  .prize-row input{flex:1}
  .section-title{font-weight:600; margin:10px 0 6px}

  /* controles ocultos si no eres admin */
  #controls{display:none}
</style>
</head>
<body>

<header>
  <div class="wrap">
    <h1>Gran Rifa — Netlify</h1>
    <div id="status" class="muted">Cargando…</div>
  </div>
</header>

<div class="wrap">

  <!-- CONTROLES ADMIN -->
  <section id="controls" class="panel">
    <h2>Controles (admin)</h2>

    <div class="row">
      <div>
        <label for="numCells">Celdas</label><br/>
        <input id="numCells" type="number" value="20" min="1" />
      </div>
      <div>
        <label for="numShapes">Formas / celda</label><br/>
        <input id="numShapes" type="number" value="2" min="1" />
      </div>
      <div>
        <label for="shapeType">Forma</label><br/>
        <select id="shapeType">
          <option value="star">Estrella</option>
          <option value="circle">Círculo</option>
          <option value="diamond">Diamante</option>
        </select>
      </div>
      <div>
        <label for="intervalSec">Intervalo (seg)</label><br/>
        <input id="intervalSec" type="number" value="5" min="1" />
      </div>
    </div>

    <div class="row">
      <button id="btnGenerate" class="primary">Generar tablero</button>
      <button id="btnReset">Reset</button>
      <button id="btnStart" class="good">Start</button>
      <button id="btnStop" class="bad">Stop</button>
      <button id="btnNext">Next</button>
    </div>

    <div style="margin-top:12px">
      <label for="namesText">Nombres (uno por línea)</label>
      <textarea id="namesText" placeholder="Escribe cada nombre en una nueva línea…"></textarea>
      <button id="btnSaveNames" class="primary">Guardar nombres</button>
    </div>

    <div style="margin-top:16px">
      <div class="section-title">Premios</div>
      <div class="prize-row">
        <input id="newPrizeText" type="text" placeholder="Nombre del premio…"/>
        <button id="btnAddPrize" class="primary">Añadir premio</button>
      </div>
      <div id="prizesList"></div>
      <button id="btnSavePrizes">Guardar lista de premios</button>
    </div>

    <div style="margin-top:16px">
      <div class="section-title">Voz</div>
      <div class="row">
        <div>
          <label>Voz</label><br/>
          <select id="voiceSelect" style="min-width:260px"></select>
        </div>
        <div>
          <label>Volumen</label><br/>
          <input id="volRange" type="range" min="0" max="1" step="0.05" value="1"/>
        </div>
        <div>
          <label>Velocidad</label><br/>
          <input id="rateRange" type="range" min="0.5" max="2" step="0.05" value="1"/>
        </div>
        <button id="btnTestVoice">Probar voz</button>
      </div>
    </div>
  </section>

  <!-- TABLERO -->
  <section class="panel">
    <div id="board"></div>
  </section>

  <!-- GANADORES -->
  <section class="panel">
    <h2>Resumen</h2>
    <div id="emptyMsg" class="muted">Sin ganador aún</div>
    <table>
      <thead><tr><th>#</th><th>Ganador</th></tr></thead>
      <tbody id="winnersBody"></tbody>
    </table>
  </section>

</div>

<script>
  // ====== helpers y nodos ======
  const qs = (s, r=document) => r.querySelector(s);

  const statusEl    = qs('#status');
  const boardEl     = qs('#board');
  const winnersBody = qs('#winnersBody');
  const emptyMsg    = qs('#emptyMsg');

  const urlp    = new URLSearchParams(location.search);
  const room    = (urlp.get('room') || 'demo').trim();
  const isAdmin = urlp.get('admin') === '1';

  const controlsEl   = qs('#controls');
  if (isAdmin && controlsEl) controlsEl.style.display = 'block';

  const numCellsEl    = qs('#numCells');
  const numShapesEl   = qs('#numShapes');
  const shapeTypeEl   = qs('#shapeType');
  const intervalSecEl = qs('#intervalSec');

  const btnGenerate  = qs('#btnGenerate');
  const btnReset     = qs('#btnReset');
  const btnStart     = qs('#btnStart');
  const btnStop      = qs('#btnStop');
  const btnNext      = qs('#btnNext');

  const namesText    = qs('#namesText');
  const btnSaveNames = qs('#btnSaveNames');

  const prizesList   = qs('#prizesList');
  const newPrizeTxt  = qs('#newPrizeText');
  const btnAddPrize  = qs('#btnAddPrize');
  const btnSavePrizes= qs('#btnSavePrizes');

  const voiceSelect  = qs('#voiceSelect');
  const volRange     = qs('#volRange');
  const rateRange    = qs('#rateRange');
  const btnTestVoice = qs('#btnTestVoice');

  // ====== voz segura ======
  const speak = (text) => {
    try {
      if (!('speechSynthesis' in window)) return;
      const u = new SpeechSynthesisUtterance(text);
      if (volRange)  u.volume = parseFloat(volRange.value || '1');
      if (rateRange) u.rate   = parseFloat(rateRange.value || '1');
      if (voiceSelect) {
        const id = voiceSelect.value;
        const voices = speechSynthesis.getVoices();
        const v = voices.find(v => v.voiceURI === id || v.name === id);
        if (v) u.voice = v;
      }
      speechSynthesis.speak(u);
    } catch {}
  };

  function populateVoices() {
    try {
      if (!('speechSynthesis' in window) || !voiceSelect) return;
      const voices = speechSynthesis.getVoices();
      voiceSelect.innerHTML = '';
      voices.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.voiceURI || v.name;
        opt.textContent = `${v.name} (${v.lang})`;
        voiceSelect.appendChild(opt);
      });
    } catch {}
  }
  if ('speechSynthesis' in window) {
    try {
      speechSynthesis.onvoiceschanged = populateVoices;
      populateVoices();
      btnTestVoice?.addEventListener('click', () => speak('Esta es una prueba de voz.'));
    } catch {}
  }

  // ====== dibujo ======
  function shapeSVG(type) {
    if (type === 'circle')  return `<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/></svg>`;
    if (type === 'diamond') return `<svg viewBox="0 0 24 24"><path d="M12 2 L22 12 L12 22 L2 12 Z"/></svg>`;
    return `<svg viewBox="0 0 24 24"><path d="M12 2l2.95 6.31 6.92.56-5.26 4.48 1.64 6.74L12 16.9 5.75 20.1l1.64-6.74L2.13 8.87l6.92-.56L12 2z"/></svg>`;
  }
  const gridCols = n => Math.ceil(Math.sqrt(n));

  let isEditing = false;
  let editingIndex = null;
  let lastState = null;
  let lastWinnersCount = 0;

  // ====== Auto-Next (correcto) ======
  let autoNextTimer = null;
  let autoNextEvery = null;

  function clearAutoNext(){
    if (autoNextTimer) {
      clearInterval(autoNextTimer);
      autoNextTimer = null;
    }
    autoNextEvery = null;
  }

  async function ensureAutoNext(state){
    if (!isAdmin) { clearAutoNext(); return; }
    if (!state?.running) { clearAutoNext(); return; }

    const ms = Math.max(1000, Number(state?.intervalMs) || 5000);

    if (autoNextEvery !== ms) {
      clearAutoNext();
      autoNextEvery = ms;

      autoNextTimer = setInterval(async () => {
        try {
          const s = await call('next'); // avanza una marca
          if (!s || (s.availableNumbers || []).length === 0) {
            clearAutoNext();
          }
        } catch(e) {
          console.warn('auto-next error:', e);
        }
      }, ms);
    }
  }

  function paintWinners(state){
    if (!winnersBody || !emptyMsg) return;
    const winners = state.winners || [];
    winnersBody.innerHTML = '';
    emptyMsg.style.display = winners.length ? 'none' : 'block';

    winners.forEach((w, idx) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${idx+1}</td><td>${(w.name || ('#'+(w.number||'-')))} — ${w.prize||'Premio'}</td>`;
      winnersBody.appendChild(tr);
    });

    if (isAdmin && winners.length > lastWinnersCount) {
      const nw = winners[winners.length - 1];
      const num = nw?.number ?? '?';
      const prize = nw?.prize ?? 'premio';
      speak(`Número ${num}, felicidades, ganaste ${prize}.`);
    }
    lastWinnersCount = winners.length;
  }

function render(state) {
  try {
    if (!statusEl || !boardEl) return;
    if (!state) {
      statusEl.textContent = 'Esperando estado…';
      boardEl.innerHTML = '';
      if (winnersBody) winnersBody.innerHTML = '';
      if (emptyMsg) emptyMsg.style.display = 'block';
      return;
    }

    // Arranca/ajusta el auto-next según el estado
    ensureAutoNext(state);

    // ✅ Cálculos “seguros”
    const totalShapes = Number.isFinite(state.numShapes) ? state.numShapes : 2;
    const n           = Number.isFinite(state.numCells)  ? state.numCells  : 20;
    const shapeTxt    = (state.shapeType || state.shape || 'star');
    const marcadas    = (state.filledCounts || [])
      .filter(c => Number.isFinite(c) && c >= totalShapes).length;

    statusEl.textContent =
      `Estado: forma=${shapeTxt} | celdas=${n} | formas/celda=${totalShapes} | marcadas=${marcadas} | corriendo=${!!state.running}`;

    if (isEditing) {  // no repintar tablero mientras editas
      paintWinners(state);
      lastState = state;
      return;
    }

    const cols = gridCols(n);
    boardEl.style.gridTemplateColumns = `repeat(${cols}, minmax(120px, 1fr))`;
    boardEl.innerHTML = '';

    for (let i = 0; i < n; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';

      const name = (state.names && state.names[i]) ? state.names[i] : `#${i+1}`;
      const h4 = document.createElement('h4');
      h4.textContent = name;

      if (isAdmin) {
        h4.title = 'Haz clic para editar. Enter o blur para guardar';
        h4.style.cursor = 'text';
        h4.addEventListener('click', () => {
          isEditing = true;
          editingIndex = i;
          h4.setAttribute('contenteditable', 'true');
          h4.focus();
          try { document.execCommand('selectAll', false, null); } catch {}
        });
        const commit = async () => {
          if (!isEditing || editingIndex !== i) return;
          h4.removeAttribute('contenteditable');
          const newName = h4.textContent.trim() || `#${i+1}`;
          if (state.names[i] !== newName) {
            state.names[i] = newName;
            try { await call('setNames', { names: state.names }); } catch {}
          }
          isEditing = false;
          editingIndex = null;
        };
        h4.addEventListener('blur', commit);
        h4.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') { e.preventDefault(); h4.blur(); }
        });
      }

      cell.appendChild(h4);

      const shapesWrap = document.createElement('div');
      shapesWrap.className = 'shapes';

      const type   = (state.shapeType || state.shape || 'star');
      const filled = Number.isFinite(state.filledCounts?.[i]) ? state.filledCounts[i] : 0;

      for (let j = 0; j < totalShapes; j++) {
        const d = document.createElement('div');
        d.className = `shape ${type} ${j < filled ? 'filled' : ''}`;
        d.innerHTML = shapeSVG(type);
        shapesWrap.appendChild(d);
      }
      cell.appendChild(shapesWrap);
      boardEl.appendChild(cell);
    }

    paintWinners(state);
    lastState = state;

    if (isAdmin && prizesList) drawPrizes(state.prizes || []);
  } catch (e) {
    console.error(e);
  }
}


  // ====== backend ======
  async function call(action, payload={}) {
    const res = await fetch('/.netlify/functions/state', {
      method: 'POST',
      headers: { 'content-type':'application/json' },
      body: JSON.stringify({ room, action, ...payload })
    });
    const data = await res.json().catch(()=>({}));
    if (!data.ok) throw new Error(data.error||'Error');
    return data.state;
  }
  async function fetchState() {
    try {
      const url = new URL('/.netlify/functions/state', location.origin);
      url.searchParams.set('room', room);
      const res = await fetch(url.toString());
      const data = await res.json().catch(()=>({}));
      if (data && data.ok) return data.state || null;
      return null;
    } catch { return null; }
  }

  // ====== poll ======
  let didAutoInit = false;

async function poll() {
  try {
    const s = await fetchState();

    // Si no hay estado y eres admin, créalo automáticamente solo una vez
    if (!s && isAdmin && !didAutoInit) {
      didAutoInit = true;
      const n  = parseInt(document.querySelector('#numCells')?.value  || '20', 10);
      const k  = parseInt(document.querySelector('#numShapes')?.value || '2', 10);
      const sh = (document.querySelector('#shapeType')?.value || 'star');
      const intervalMs = Math.max(1000, parseInt((document.querySelector('#intervalSec')?.value || '5'),10) * 1000);

      await call('generate', { n, k, shape: sh, intervalMs });
      return; // No renderices todavía, espera al próximo poll
    }

    // Renderiza normalmente si ya hay estado
    render(s);

  } catch(e) {
    console.error("Error en poll:", e);
  }
}

poll();
setInterval(poll, 1000);

  // ====== eventos admin ======
  // ====== eventos admin ======
if (isAdmin) {
  btnGenerate?.addEventListener('click', async () => {
    clearAutoNext(); // por si había uno en marcha
    const n  = parseInt(numCellsEl?.value  || '20',10);
    const k  = parseInt(numShapesEl?.value || '2',10);
    const sh = (shapeTypeEl?.value || 'star');
    const intervalMs = Math.max(
      1000,
      parseInt((intervalSecEl?.value || '5'),10) * 1000
    );
    await call('generate', { n, k, shape: sh, intervalMs }); // guarda intervalMs
    poll();
  });

  btnReset?.addEventListener('click', async () => {
    clearAutoNext();
    await call('reset');
    poll();
  });

  btnStart?.addEventListener('click', async () => {
    await call('start'); // running=true
    // ensureAutoNext arrancará el timer en el siguiente poll
    poll();
  });

  // 🚩 corregido: sin espacios antes de ?.
  btnStop?.addEventListener('click', async () => {
    clearAutoNext();
    await call('stop');
    poll();
  });

  // 🚩 corregido: sin espacios antes de ?.
  btnNext?.addEventListener('click', async () => {
    await call('next');
    poll();
  });

  btnSaveNames?.addEventListener('click', async () => {
    const raw = (namesText?.value || '').trim();
    const names = raw.split('\n').map(s => s.trim()).filter(Boolean);
    await call('setNames', { names });
    poll();
  });

  btnAddPrize?.addEventListener('click', async () => {
    const name = (newPrizeTxt?.value || '').trim();
    if (!name) return;
    await call('addPrize', { prize: name });
    if (newPrizeTxt) newPrizeTxt.value = '';
    poll();
  });

  btnSavePrizes?.addEventListener('click', async () => {
    if (!prizesList) return;
    const rows = prizesList.querySelectorAll('input[type="text"]');
    const prizes = Array.from(rows).map(i => i.value.trim()).filter(Boolean);
    await call('setPrizes', { prizes });
    poll();
  });
}


  // ====== gestor de premios (dibujo) ======
  function drawPrizes(prizes) {
    try {
      if (!prizesList) return;
      prizesList.innerHTML = '';
      prizes.forEach((p, idx) => {
        const row = document.createElement('div');
        row.className = 'prize-row';
        const inp = document.createElement('input');
        inp.type = 'text'; inp.value = p;
        const del = document.createElement('button');
        del.textContent = 'Eliminar'; del.className = 'bad';
        row.appendChild(inp); row.appendChild(del);
        prizesList.appendChild(row);
        del.addEventListener('click', async () => {
          await call('removePrize', { index: idx });
          poll();
        });
      });
    } catch {}
  }
</script>
</body>
</html>



